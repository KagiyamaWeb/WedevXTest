import os
import asyncio
import google.generativeai as genai
from dotenv import load_dotenv
from sqlalchemy.orm import Session
from app.database import get_db, SessionLocal
from app import models
import logging

load_dotenv()

genai.configure(api_key=os.getenv('GEMINI_API_KEY'))

model = genai.GenerativeModel("gemini-2.0-flash")

DEFAULT_FALLBACK_TASKS = [{'name': 'Unknown', 'status': models.TaskStatus.PENDING}]  # Define default fallback tasks

def generate_construction_tasks(project_name: str, location: str) -> list:
    prompt = f'''Generate a detailed construction task list for building a {project_name} in {location}.
    Return as a bullet-point list of tasks.'''
    
    try:
        response = model.generate_content(prompt)
        
        # Handle different response formats
        if ',' in response.text:
            tasks = [task.strip() for task in response.text.split(',') if task.strip()]
        else:
            tasks = [line.strip().lstrip('-* ') 
                    for line in response.text.split('\n') 
                    if line.strip()]
        
        if not tasks:
            raise ValueError('No tasks generated by Gemini API')
        
        return [{'name': task, 'status': models.TaskStatus.PENDING} for task in tasks]
    
    except Exception as e:
        logging.exception(f'Gemini API error: {str(e)}')
        raise RuntimeError("Task generation failed") from e


async def simulate_task_processing():
    while True:
        await asyncio.sleep(10)  # Process tasks every 10 seconds
        db = SessionLocal()
        try:
            # Process oldest incomplete project
            project = db.query(models.Project).filter(
                models.Project.status.in_([
                    models.ProjectStatus.PROCESSING,  # Use directly imported enum
                    models.ProjectStatus.IN_PROGRESS
                ])
            ).order_by(models.Project.created_at).first()

            if project:
                # Transition from PROCESSING to IN_PROGRESS
                if project.status == models.ProjectStatus.PROCESSING:
                    project.status = models.ProjectStatus.IN_PROGRESS
                    db.commit()

                # Process first pending task
                task = db.query(models.Task).filter(
                    models.Task.project_id == project.id,
                    models.Task.status == models.TaskStatus.PENDING
                ).first()

                if task:
                    task.status = models.TaskStatus.COMPLETED
                    db.commit()

                # Check if all tasks completed
                pending_tasks = db.query(models.Task).filter(
                    models.Task.project_id == project.id,
                    models.Task.status != models.TaskStatus.COMPLETED
                ).count()

                if pending_tasks == 0:
                    project.status = models.ProjectStatus.COMPLETED
                    db.commit()

        finally:
            db.close()
